

// @ts-nocheck - js-yaml and others are loaded via script tags
export async function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsText(file);
  });
}

export async function fileToBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = error => reject(error);
  });
}

export function formatJson(jsonStr: string, indent: number = 2): string {
  try {
    return JSON.stringify(JSON.parse(jsonStr), null, indent);
  } catch (e) {
    throw new Error('Malformed JSON data');
  }
}

/**
 * Excel Parsing using SheetJS
 */
export async function xlsxToJson(file: File): Promise<string> {
  const data = await file.arrayBuffer();
  // @ts-ignore
  const workbook = XLSX.read(data);
  const firstSheetName = workbook.SheetNames[0];
  const worksheet = workbook.Sheets[firstSheetName];
  // @ts-ignore
  const json = XLSX.utils.sheet_to_json(worksheet);
  return JSON.stringify(json, null, 2);
}

export async function xlsxToCsv(file: File): Promise<string> {
  const data = await file.arrayBuffer();
  // @ts-ignore
  const workbook = XLSX.read(data);
  const firstSheetName = workbook.SheetNames[0];
  const worksheet = workbook.Sheets[firstSheetName];
  // @ts-ignore
  return XLSX.utils.sheet_to_csv(worksheet);
}

export function jsonToSql(jsonStr: string, tableName: string = 'imported_data'): string {
  try {
    const data = JSON.parse(jsonStr);
    const array = Array.isArray(data) ? data : [data];
    if (array.length === 0) return "-- No data found";
    
    // Check if it's an array of objects
    if (typeof array[0] !== 'object' || array[0] === null) {
      throw new Error('SQL conversion requires an array of objects.');
    }

    const headers = Object.keys(array[0]);
    let sql = `-- Generated by CoreConvert\n`;
    
    for (const row of array) {
      const values = headers.map(header => {
        const val = row[header];
        if (val === null || val === undefined) return 'NULL';
        if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
        if (typeof val === 'boolean') return val ? '1' : '0';
        return val;
      });
      sql += `INSERT INTO ${tableName} (${headers.join(', ')}) VALUES (${values.join(', ')});\n`;
    }
    return sql;
  } catch (e) {
    throw new Error(e.message || 'Invalid JSON for SQL conversion');
  }
}

export function jsonToCsv(jsonStr: string, delimiter: string = ','): string {
  try {
    const data = JSON.parse(jsonStr);
    const array = Array.isArray(data) ? data : [data];
    if (array.length === 0) return "";
    
    // Ensure we are dealing with objects
    if (typeof array[0] !== 'object' || array[0] === null) {
      throw new Error('CSV requires an array of objects. Current data is primitive.');
    }

    const headers = Object.keys(array[0]);
    const rows = [];
    rows.push(headers.join(delimiter));
    
    for (const row of array) {
      const values = headers.map(header => {
        let val = row[header];
        if (val === null || val === undefined) val = '';
        const escaped = ('' + val).replace(/"/g, '""');
        return `"${escaped}"`;
      });
      rows.push(values.join(delimiter));
    }
    return rows.join('\n');
  } catch (e) {
    throw new Error(e.message || 'Invalid JSON for CSV/TSV conversion');
  }
}

export function csvToJson(csvStr: string, delimiter: string = ','): string {
  const lines = csvStr.trim().split('\n');
  if (lines.length < 2) return "[]";
  
  const headers = lines[0].split(delimiter).map(h => h.trim().replace(/^"|"$/g, ''));
  const result = [];
  
  for (let i = 1; i < lines.length; i++) {
    const obj: any = {};
    const currentLine = lines[i].split(delimiter);
    headers.forEach((header, index) => {
      let val = currentLine[index]?.trim().replace(/^"|"$/g, '') || "";
      if (!isNaN(val as any) && val !== "") obj[header] = Number(val);
      else if (val.toLowerCase() === 'true') obj[header] = true;
      else if (val.toLowerCase() === 'false') obj[header] = false;
      else obj[header] = val;
    });
    result.push(obj);
  }
  return JSON.stringify(result, null, 2);
}

export function jsonToYaml(jsonStr: string): string {
  try {
    const data = JSON.parse(jsonStr);
    return jsyaml.dump(data);
  } catch (e) {
    throw new Error('JSON to YAML conversion failed');
  }
}

export function yamlToJson(yamlStr: string): string {
  try {
    const data = jsyaml.load(yamlStr);
    return JSON.stringify(data, null, 2);
  } catch (e) {
    throw new Error('Invalid YAML data');
  }
}

export function xmlToJson(xmlStr: string): string {
  try {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlStr, "text/xml");
    
    const parseNode = (node: Node): any => {
      if (node.nodeType === Node.TEXT_NODE) return node.nodeValue?.trim();
      if (node.nodeType !== Node.ELEMENT_NODE) return null;

      const obj: any = {};
      if (node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE) {
        return node.childNodes[0].nodeValue?.trim();
      }

      for (let i = 0; i < node.childNodes.length; i++) {
        const child = node.childNodes[i];
        if (child.nodeType === Node.ELEMENT_NODE) {
          const childVal = parseNode(child);
          if (obj[child.nodeName]) {
            if (!Array.isArray(obj[child.nodeName])) {
              obj[child.nodeName] = [obj[child.nodeName]];
            }
            obj[child.nodeName].push(childVal);
          } else {
            obj[child.nodeName] = childVal;
          }
        }
      }
      return obj;
    };

    const result = parseNode(xmlDoc.documentElement);
    return JSON.stringify(result, null, 2);
  } catch (e) {
    throw new Error('Invalid XML data');
  }
}

export function jsonToXml(jsonStr: string): string {
  try {
    const data = JSON.parse(jsonStr);
    
    const toXml = (obj: any, rootName: string): string => {
      let xml = `<${rootName}>`;
      for (const prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
          if (Array.isArray(obj[prop])) {
            for (const item of obj[prop]) {
              xml += toXml(item, prop);
            }
          } else if (typeof obj[prop] === 'object' && obj[prop] !== null) {
            xml += toXml(obj[prop], prop);
          } else {
            xml += `<${prop}>${obj[prop]}</${prop}>`;
          }
        }
      }
      xml += `</${rootName}>`;
      return xml;
    };

    return `<?xml version="1.0" encoding="UTF-8"?>\n${toXml(data, 'root')}`;
  } catch (e) {
    throw new Error('JSON to XML conversion failed');
  }
}

export function markdownToHtml(md: string): string {
  return marked.parse(md);
}

/**
 * Uses Mammoth.js to convert DOCX to HTML
 */
export async function docxToHtml(file: File): Promise<string> {
   const mammoth = (window as any).mammoth;
   if (!mammoth) throw new Error("Mammoth library not loaded");
   const buffer = await file.arrayBuffer();
   const result = await mammoth.convertToHtml({ arrayBuffer: buffer });
   return result.value;
}

export async function docxToText(file: File): Promise<string> {
   const mammoth = (window as any).mammoth;
   if (!mammoth) throw new Error("Mammoth library not loaded");
   const buffer = await file.arrayBuffer();
   const result = await mammoth.extractRawText({ arrayBuffer: buffer });
   return result.value;
}

/**
 * Uses Turndown to convert HTML to Markdown
 */
export function htmlToMarkdown(html: string): string {
    const TurndownService = (window as any).TurndownService;
    if (!TurndownService) throw new Error("Turndown library not loaded");
    const turndownService = new TurndownService();
    return turndownService.turndown(html);
}

/**
 * Simple XML Formatting
 */
export function formatXml(xml: string, minify: boolean = false): string {
    if (minify) {
        return xml.replace(/>\s+</g, '><').trim();
    }
    
    // Simple heuristic indentation
    let formatted = '';
    const reg = /(>)(<)(\/*)/g;
    xml = xml.replace(reg, '$1\r\n$2$3');
    let pad = 0;
    const lines = xml.split('\r\n');
    
    lines.forEach(node => {
        let indent = 0;
        if (node.match(/.+<\/\w[^>]*>$/)) {
            indent = 0;
        } else if (node.match(/^<\/\w/)) {
            if (pad !== 0) pad -= 1;
        } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
            indent = 1;
        } else {
            indent = 0;
        }

        let padding = '';
        for (let i = 0; i < pad; i++) padding += '  ';
        formatted += padding + node + '\r\n';
        pad += indent;
    });
    
    return formatted.trim();
}

export function urlEncode(text: string): string {
    return encodeURIComponent(text);
}

export function urlDecode(text: string): string {
    return decodeURIComponent(text);
}

export function base64Decode(text: string): string {
    try {
        // Handle common data URI prefix stripping
        const cleanText = text.replace(/^data:.*;base64,/, '');
        return atob(cleanText);
    } catch (e) {
        throw new Error("Invalid Base64 string");
    }
}