
import { ConversionType } from '../types';
import JSZip from 'jszip';
import { jsPDF } from 'jspdf';

interface ConversionResult {
  url: string;
  name: string;
  blob: Blob;
}

/**
 * Main entry point for Presentation conversion.
 * Supports .pptx, .pptm, .ppsx, .ppsm, .potx, .potm, .sldx, .sldm
 * NOTE: Legacy binary .ppt files cannot be parsed client-side with this engine.
 */
export async function convertPresentationFile(file: File, type: ConversionType): Promise<ConversionResult> {
  const baseName = file.name.split('.').slice(0, -1).join('.');

  // Special Handling: Text to PPTX (Creation)
  if (type === 'TEXT_TO_PPTX') {
    const text = await file.text();
    return createPptxFromText(text, baseName, 'text');
  }

  // Special Handling: Markdown to PPTX (Creation)
  if (type === 'MARKDOWN_TO_PPTX') {
    const text = await file.text();
    return createPptxFromText(text, baseName, 'markdown');
  }

  // Special Handling: Convert Presentation to PPTX (e.g. PPSX -> PPTX)
  if (type === 'PRESENTATION_TO_PPTX') {
     // For OpenXML formats, the internal structure is largely compatible.
     // To "Repair" or "Convert" a PPSX to PPTX, we often just need to verify it's a valid ZIP and save with .pptx extension.
     // We do a sanity check by loading it with JSZip first.
     try {
       const zip = await JSZip.loadAsync(file);
       // Re-generate to ensure clean headers
       const blob = await zip.generateAsync({ type: 'blob' });
       return createResult(blob, `${baseName}.pptx`, 'application/vnd.openxmlformats-officedocument.presentationml.presentation');
     } catch (e) {
       if (file.name.toLowerCase().endsWith('.ppt')) {
           throw new Error("Legacy binary .ppt files cannot be converted to .pptx client-side.");
       }
       throw new Error("Could not parse source presentation.");
     }
  }

  // --- Extraction Conversions ---
  const slides = await extractSlidesFromPptx(file);

  if (slides.length === 0) {
    throw new Error("No text content or slides could be extracted from this presentation.");
  }

  switch (type) {
    case 'PRESENTATION_TO_TEXT':
      const textContent = slides.map((s, i) => `--- Slide ${i + 1} ---\n\n${s}`).join('\n\n');
      return createResult(textContent, `${baseName}.txt`, 'text/plain');

    case 'PRESENTATION_TO_HTML':
      const htmlContent = generateHtml(slides, baseName);
      return createResult(htmlContent, `${baseName}.html`, 'text/html');

    case 'PRESENTATION_TO_PDF':
      const pdfBlob = await generatePdf(slides);
      return createResult(pdfBlob, `${baseName}.pdf`, 'application/pdf');

    case 'PRESENTATION_TO_JSON':
      const jsonContent = JSON.stringify({ title: baseName, slides: slides.map((text, i) => ({ id: i + 1, content: text })) }, null, 2);
      return createResult(jsonContent, `${baseName}.json`, 'application/json');

    default:
      throw new Error(`Unsupported presentation conversion: ${type}`);
  }
}

/**
 * Creates a simple PPTX file from text or markdown using pptxgenjs.
 */
async function createPptxFromText(text: string, title: string, mode: 'text' | 'markdown'): Promise<ConversionResult> {
    try {
        // Dynamic import to keep bundle small
        // @ts-ignore
        const pptxgen = (await import('pptxgenjs')).default;
        const pres = new pptxgen();

        pres.layout = 'LAYOUT_16x9';
        pres.title = title;

        // Cover Slide
        const slide = pres.addSlide();
        slide.addText(title, { x: 1, y: 1, w: '80%', h: 1, fontSize: 36, align: 'center', bold: true, color: '000000' });
        slide.addText(`Generated by CoreConvert`, { x: 1, y: 2.5, w: '80%', h: 0.5, fontSize: 12, align: 'center', color: '888888' });

        if (mode === 'markdown') {
            // Split by Headers (#) to create new slides
            const sections = text.split(/^#+\s/gm);
            // First section might be empty or preamble
            for (const section of sections) {
                if (!section.trim()) continue;
                
                const lines = section.trim().split('\n');
                const header = lines[0]; // The header text (stripped of # by split, or mostly)
                const body = lines.slice(1).join('\n').trim();

                const s = pres.addSlide();
                s.addText(header, { x: 0.5, y: 0.5, w: '90%', h: 1, fontSize: 24, bold: true, color: '363636' });
                if (body) {
                   s.addText(body, { x: 0.5, y: 1.5, w: '90%', h: 3, fontSize: 14, color: '666666', valign: 'top' });
                }
            }
        } else {
            // Text Mode: Pagination by roughly 500 chars or double newlines
            const paragraphs = text.split(/\n\s*\n/);
            for (const para of paragraphs) {
                if (!para.trim()) continue;
                const s = pres.addSlide();
                s.addText(para.trim(), { x: 0.5, y: 0.5, w: '90%', h: '80%', fontSize: 14, color: '333333', valign: 'top' });
            }
        }

        const blob = await pres.write({ outputType: 'blob' });
        return createResult(blob as Blob, `${title}.pptx`, 'application/vnd.openxmlformats-officedocument.presentationml.presentation');

    } catch (e) {
        console.error("PPTX Generation failed", e);
        throw new Error("Failed to generate PPTX file. Ensure your browser supports WebAssembly/modern APIs.");
    }
}

/**
 * Extracts raw text from slides by unzipping the OOXML file
 * and parsing the internal XML structure.
 */
async function extractSlidesFromPptx(file: File): Promise<string[]> {
  let zip: JSZip;
  try {
    zip = await JSZip.loadAsync(file);
  } catch (e) {
    // If JSZip fails, it's likely a binary .ppt or corrupted file
    if (file.name.toLowerCase().endsWith('.ppt')) {
        throw new Error("Legacy binary .ppt files are not supported. Please save as .pptx and try again.");
    }
    throw new Error("Could not parse presentation file structure.");
  }

  const slides: string[] = [];
  
  // Find all slide XML files
  // Standard path: ppt/slides/slide1.xml
  const slideFiles = Object.keys(zip.files).filter(name => name.match(/ppt\/slides\/slide\d+\.xml/));
  
  // Sort naturally (slide1, slide2, slide10...)
  slideFiles.sort((a, b) => {
    const numA = parseInt(a.match(/slide(\d+)/)?.[1] || '0');
    const numB = parseInt(b.match(/slide(\d+)/)?.[1] || '0');
    return numA - numB;
  });

  const parser = new DOMParser();

  for (const path of slideFiles) {
    const xmlStr = await zip.file(path)?.async('string');
    if (!xmlStr) continue;

    const xml = parser.parseFromString(xmlStr, "text/xml");
    
    // In OpenXML PresentationML, text is usually within <a:t> tags
    // Sometimes it's nested deep within paragraphs <a:p> and runs <a:r>
    const textNodes = xml.getElementsByTagName('a:t');
    const slideText: string[] = [];

    for (let i = 0; i < textNodes.length; i++) {
      const node = textNodes[i];
      if (node.textContent) {
        slideText.push(node.textContent);
      }
    }

    slides.push(slideText.join(' '));
  }

  return slides;
}

function createResult(content: string | Blob, name: string, type: string): ConversionResult {
  const blob = content instanceof Blob ? content : new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  return { url, name, blob };
}

function generateHtml(slides: string[], title: string): string {
  const slideDivs = slides.map((text, i) => `
    <div class="slide">
      <div class="slide-number">Slide ${i + 1}</div>
      <div class="slide-content">${text || '(No text content detected)'}</div>
    </div>
  `).join('\n');

  return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${title}</title>
<style>
  body { 
    font-family: system-ui, -apple-system, sans-serif; 
    background-color: #f0f0f0;
    padding: 20px;
    margin: 0;
  }
  .slide { 
    background: white; 
    padding: 40px; 
    margin: 0 auto 30px auto; 
    max-width: 800px; 
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    border-radius: 4px;
    aspect-ratio: 16/9;
    display: flex;
    flex-direction: column;
  }
  .slide-number {
    font-size: 12px;
    color: #888;
    text-transform: uppercase;
    font-weight: bold;
    margin-bottom: 20px;
    border-bottom: 1px solid #eee;
    padding-bottom: 10px;
  }
  .slide-content {
    font-size: 18px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
  }
</style>
</head>
<body>
${slideDivs}
</body>
</html>`;
}

async function generatePdf(slides: string[]): Promise<Blob> {
  // @ts-ignore
  const doc = new jsPDF({ unit: 'pt', format: 'a4', orientation: 'landscape' });
  
  const width = doc.internal.pageSize.getWidth();
  const height = doc.internal.pageSize.getHeight();
  const margin = 50;
  
  doc.setFont("helvetica", "normal");

  slides.forEach((text, i) => {
    if (i > 0) doc.addPage();
    
    // Header
    doc.setFontSize(10);
    doc.setTextColor(150);
    doc.text(`Slide ${i + 1}`, margin, margin);
    
    // Content
    doc.setFontSize(16);
    doc.setTextColor(0);
    
    const maxLineWidth = width - (margin * 2);
    const splitLines = doc.splitTextToSize(text, maxLineWidth);
    
    doc.text(splitLines, margin, margin + 40);
  });

  return doc.output('blob');
}
